\begin{center}
    \section{jemalloc 分析}
\end{center}

\setlength{\parindent}{2em}
此处分析的版本为jemalloc-5.0.1中的\verb+ malloc+实现。
为了方便调试，我们可以在编译\verb+ jemalloc+的时候保留调试符号信息：\verb+ --enable-debug+。
修改\verb+ Makefile+，使用jemalloc编译how2heap的二进制文件：
\begin{minted}[breaklines, frame=lines]{bash}
PROGRAMS = fastbin_dup fastbin_dup_into_stack fastbin_dup_consolidate unsafe_unlink house_of_spirit poison_null_byte malloc_playground first_fit house_of_lore overlapping_chunks overlapping_chunks_2 house_of_force unsorted_bin_attack house_of_einherjar house_of_orange
CFLAGS += -std=c99 -g
LDFLAGS += -L/usr/local/jemalloc/lib
LDLIBS += -ljemalloc
# Convenience to auto-call mcheck before the first malloc()
#CFLAGS += -lmcheck

all: $(PROGRAMS)
clean:
    rm -f $(PROGRAMS)
\end{minted}

\subsection{jemalloc的介绍}

现代CPU已大多数为多核CPU，多线程的应用程序也越来越广泛，内存的分配与回收也越来越成为制约程序性能的一大原因。因此为多核多线程的堆管理器jemalloc应运而生。

在过去，分配器使用\verb+ sbrk(2)+来获得内存，由于多种原因，其中包括竞争条件，碎片增加以及最大可用内存的人为限制，这是不理想的。 如果操作系统支持\verb+ sbrk(2)+，则该分配器按照该优先顺序同时使用\verb+ mmap(2)+和\verb+ sbrk(2)+; 否则仅使用\verb+ mmap(2)+。

这个堆分配器会使用多arena的方式来减少多核系统上多线程程序的锁竞争。除了多个arena之外，该分配器还支持线程特定的缓存，以便可以完全避免大多数分配请求的同步。 这样的缓存允许在正常情况下进行快速分配，但是它增加了内存的使用和分段，因为有限数量的对象可以在每个线程缓存中一直保存被分配的状态。

从jemalloc 5.0.0版本开始，不再使用"chunks"这个数据结构进行虚拟内存的管理，而是去使用一个新的，页面对齐的数据结构——extents。（于是之前几乎所有关于jemalooc的资料全部作废了，就是一夜回到解放前看源码）

在jemalloc的最新设计中，内存区域在概念上被划分为extents，extents始终与页面大小的倍数对齐，这种对齐可以让用户更快速的找到储存的元数据。用户的对象被分为大小两类，连续的小对象包含一个slab，也就是一个单一的extent，而大的对象则有自己的extents支持。

小的对象由slab分组管理，而每一个slab则维护一个bitmap追踪哪些区域正在被使用。不超过1 quantum一半的分配请求（8或16，依据架构而定）将四舍五入到最接近的2的幂，至少是\verb+ sizeof(double)+。

\subsection{unsafe\_unlink}

由于jemalloc的实现和ptmalloc并不相同，没有采用边界标记来在堆分配的时候标记数据，而是使用了bitmap标记内存的使用情况，因此jemalloc对unlink攻击免疫，所以unlink攻击无法成功。
\begin{minted}[breaklines, frame=lines]{bash}
$ how2heap ./unsafe_unlink
The global chunk0_ptr is at 0x601070, pointing to 0x7ff94e61e000
The victim chunk we are going to corrupt is at 0x7ff94e61e080

Fake chunk fd: 0x601058
Fake chunk bk: 0x601060

Original value: AAAAAAAA
New Value: AAAAAAAA

\end{minted}

\subsection{house\_of\_spirit}

攻击失败，运行结果如下：
\begin{minted}[breaklines, frame=lines]{bash}
$ how2heap ./house_of_spirit
We will overwrite a pointer to point to a fake 'fastbin' region. This region contains two chunks.
The first one:  0x7ffd67374070
The second one: 0x7ffd67374090
Overwritting our pointer with the address of the fake region inside the fake first chunk, 0x7ffd67374070.
Freeing the overwritten pointer.
<jemalloc>: src/rtree.c:205: Failed assertion: "!dependent || leaf != NULL"
[1]    27382 abort      ./house_of_spirit

\end{minted}

free时会调用jemalloc中的\verb+ free()+，跟踪进入\verb+ free()+调用的\verb+ ifree()+：
\begin{minted}[breaklines, frame=lines]{c}
ifree(tsd=0x7ffff7fde728, ptr=0x7fffffffe480, tcache=0x7ffff7fde8e0, slow_path=0x1);
\end{minted}

继续跟入，\verb+ tsd_tsdn()+函数十分简洁，且作用是强制类型转换，我们可以略过，进入\verb+ ifree()+中调用的\verb+ idalloctm()+函数，再进入\verb+ arena_dalloc()+：
\begin{minted}[breaklines, frame=lines]{c}
// arena_dalloc(tsdn=0x7ffff7fde728, ptr=0x7fffffffe480, tcache=0x7ffff7fde8e0, alloc_ctx=0x7fffffffe3f0, slow_path=0x1)
    // config_debug = 1, 进入
    if (config_debug) {
        rtree_ctx = tsd_rtree_ctx(tsdn_tsd(tsdn));
        // extent=0x00007fffffffe348  →  [...]  →  0x0000000100000101, tsdn=0x00007fffffffe328  →  [...]  →  0x0000000100000101
        extent_t *extent = rtree_extent_read(tsdn, &extents_rtree,
            rtree_ctx, (uintptr_t)ptr, true);
        // extent=0x00007fffffffe348  →  0x0000000000000000
        assert(szind == extent_szind_get(extent));
        assert(szind < NSIZES);
        assert(slab == extent_slab_get(extent));
    }
    // 略去无关函数
\end{minted}

我们在\verb+ extent_szind_get(extent)+函数中调用的\verb+ extent_szind_get_maybe_invalid(extent)+中有如下操作：
\begin{minted}[breaklines, frame=lines]{c}
    static inline szind_t
        extent_szind_get_maybe_invalid(const extent_t *extent) {
        // extent=0x00007fffffffe2a8  →  0x0000000000000000
        szind_t szind = (szind_t)((extent->e_bits & EXTENT_BITS_SZIND_MASK) >>
            EXTENT_BITS_SZIND_SHIFT);
        assert(szind <= NSIZES);
        return szind;
}

\end{minted}

extent的值由\verb+ 0x00007fffffffe2a8+变成了一个非法地址\verb+ 0x0000000000000000+，因此\verb+ extent->e_bits+无法计算，所以，\verb+ szind+的值与\verb+ NSIZES+（该值此时为0xE8）无法比较，因此程序收到终止信号，程序退出。

\subsection{house\_of\_lore}

攻击失败：
\begin{minted}[breaklines, frame=lines]{bash}
$ how2heap ./house_of_lore 
Allocated the victim (small) chunk: 0x7fd6d8878000
stack_buffer_1: 0x7ffd6419e2a0
stack_buffer_2: 0x7ffd6419e280

Freeing the victim chunk 0x7fd6d8878000, it will be inserted in the unsorted bin
victim->fd: 0x5a5a5a5a5a5a5a5a
victim->bk: 0x5a5a5a5a5a5a5a5a

Malloc a chunk that can't be handled by the unsorted bin, nor the SmallBin: 0x7fd6d887a000
The victim chunk 0x7fd6d8878000 will be inserted in front of the SmallBin
victim->fd: 0x5a5a5a5a5a5a5a5a
victim->bk: 0x5a5a5a5a5a5a5a5a

Now emulating a vulnerability that can overwrite the victim->bk pointer
This last malloc should return a chunk at the position injected in bin->bk: 0x7fd6d8878000
The fd pointer of stack_buffer_2 has changed: 0x7ffd6419e2a0

\end{minted}

gdb打开应用，在free之前下断点，堆布局是这样的：
\begin{minted}[breaklines, frame=lines]{c}
gef> x/20gx victim-2
0x7ffff64a4ff0: 0x0000000000000000  0x0000000000000000
0x7ffff64a5000: 0x4141414141414141  0x4141414141414141
...           : ...                 ..
0x7ffff64a5070: 0x4141414141414141  0x4141414141414141
0x7ffff64a5080: 0x0000000000000000  0x0000000000000000
\end{minted}

之前就已经提到过，jemalloc没有采用边界标记法表示内存，因此没有在分配内存的附近有标记，如果使用glibc的堆布局就如下所示：
\begin{minted}[breaklines, frame=lines]{c}
gef> x/20gx victim-2
0x603000:   0x0000000000000000  0x0000000000000091 <- size
0x603010:   0x4141414141414141  0x4141414141414141
...     :   ...                 ...
0x603080:   0x4141414141414141  0x4141414141414141
0x603090:   0x0000000000000000  0x0000000000000021 <- next size
\end{minted}

\verb+ free()+之后，我们的堆布局变成了下面的样子：
\begin{minted}[breaklines, frame=lines]{bash}
gef> x/20gx victim-2
0x7ffff64a4ff0: 0x0000000000000000  0x0000000000000000
0x7ffff64a5000: 0x5a5a5a5a5a5a5a5a  0x5a5a5a5a5a5a5a5a
...           : ...                 ...
0x7ffff64a5070: 0x5a5a5a5a5a5a5a5a  0x5a5a5a5a5a5a5a5a
0x7ffff64a5080: 0x0000000000000000  0x0000000000000000
\end{minted}

jemalloc在free某块内存之后，不仅会在bitmap中标记，还会填充特定的字符，因此攻击失效。

\subsection{house\_of\_einherjar}

\subsection{house\_of\_orange}

\subsection{house\_of\_force}

\subsection{poison\_null\_byte}

\subsection{unsorted\_bin\_attack}

\subsection{unsorted\_bin\_into\_stack}

\subsection{fastbin\_dup}

\subsection{fastbin\_dup\_into\_stack}

\subsection{overlapping\_chunks}

\subsection{overlapping\_chunks\_2}

\newpage